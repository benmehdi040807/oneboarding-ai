// app/api/pay/authorize/return/route.ts
import { NextRequest, NextResponse } from "next/server";
import { ppAccessToken, PP_BASE } from "@/lib/paypal";
import prisma from "@/lib/db";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";
export const revalidate = 0;

function baseUrl() {
  const b = process.env.NEXT_PUBLIC_BASE_URL || "https://oneboardingai.com";
  return b.endsWith("/") ? b.slice(0, -1) : b;
}

async function captureOrder(orderId: string) {
  const token = await ppAccessToken();
  const url = `${PP_BASE.replace(/\/$/, "")}/v2/checkout/orders/${orderId}/capture`;
  const res = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json",
      "PayPal-Request-Id": `${Date.now()}-${Math.random().toString(36).slice(2)}`, // idempotence light
    },
    cache: "no-store",
  });
  const data = await res.json().catch(() => ({}));
  if (!res.ok) {
    const msg =
      (data?.details && data.details[0]?.issue) ||
      data?.message ||
      `PP_CAPTURE_FAIL ${res.status}`;
    throw new Error(msg);
  }
  return data;
}

export async function GET(req: NextRequest) {
  const B = baseUrl();

  try {
    const url = new URL(req.url);
    // PayPal Orders v2 renvoie ?token=<orderId>
    const orderId = url.searchParams.get("token");
    if (!orderId) {
      // Cookie d’erreur courte durée pour le bridge client
      return NextResponse.redirect(`${B}/`, {
        status: 302,
        headers: {
          "Set-Cookie": `ob.deviceAuth=error; Path=/; Max-Age=20; SameSite=Lax; Secure`,
        },
      });
    }

    // 1) Capture côté PayPal (idempotent si rechargé)
    const capture = await captureOrder(orderId);

    // 2) Retrouver l’intent stocké (créé par /api/pay/authorize-device)
    const intent = await prisma.deviceOrderIntent.findUnique({
      where: { orderId },
      select: { id: true, userId: true, deviceId: true, amount: true, currency: true, status: true },
    });

    // 3) Si on n’a pas de trace, on n’empêche pas l’UX ; on marque juste l’échec “server-side link”
    if (!intent) {
      return NextResponse.redirect(`${B}/`, {
        status: 302,
        headers: {
          "Set-Cookie": `ob.deviceAuth=ok; Path=/; Max-Age=20; SameSite=Lax; Secure`,
        },
      });
    }

    // 4) Marquer l’intent comme capturé
    await prisma.deviceOrderIntent.update({
      where: { orderId },
      data: {
        status: "CAPTURED",
        payload: JSON.stringify({ capturedAt: new Date().toISOString(), capture }),
      },
    });

    // 5) Autoriser l’appareil (création si besoin)
    await prisma.device.upsert({
      where: { userId_deviceId: { userId: intent.userId, deviceId: intent.deviceId } },
      create: {
        userId: intent.userId,
        deviceId: intent.deviceId,
        authorized: true,
        revokedAt: null,
        lastAuthorizedAt: new Date(),
      },
      update: {
        authorized: true,
        revokedAt: null,
        lastAuthorizedAt: new Date(),
      },
    });

    // 6) Rediriger vers la home en posant un cookie court lu par le bridge client
    //    (le bridge émettra ob:device-authorized à l’arrivée)
    return NextResponse.redirect(`${B}/`, {
      status: 302,
      headers: {
        // valeur "ok" (20s) — le bridge lira + effacera
        "Set-Cookie": `ob.deviceAuth=ok; Path=/; Max-Age=20; SameSite=Lax; Secure`,
      },
    });
  } catch (e) {
    // UX: on revient à la home avec un flag cookie d’erreur courte durée
    return NextResponse.redirect(`${baseUrl()}/`, {
      status: 302,
      headers: {
        "Set-Cookie": `ob.deviceAuth=error; Path=/; Max-Age=20; SameSite=Lax; Secure`,
      },
    });
  }
}
